fpmon					  ;включаем работу с дробями
jmp main                  ;идем выполнять основную программу


;===================================================================
;                Функция считает корень ax+b = 0
;         Коэффициенты лежат в eax,ebx соответственно
;                В edi лежит корень уравнения
; В ecx лежит количество корней ( == -1 -> бесконечно много корней )
;===================================================================
solve_linear:
	cmp eax, 0.0
	je mb_many_root	      ;первая проверка, что a == 0

	mov edi, ebx          ;честное вычисление корня
	mul edi, -1.0
	div edi, eax
	mov edx, 1.0

	jmp end_solve_linear

mb_many_root:
	cmp ebx, 0.0         ;если таки a == 0, b == 0, то корней б\много
	je many_roots
	mov edx, 0.0		 ;в противном случае корней вообще нет
	jmp end_solve_linear

many_roots:
	mov edx, -1.0	     ;б\много корней
	jmp end_solve_linear

end_solve_linear:
	ret


;===================================================================
;           Функция считает корни ax^2 + bx + c = 0
;        Коэффициенты лежат в eax, ebx, ecx соответственно
;                В esi,edi лежат корени уравнения
; В ecx лежит количество корней ( == -1 -> бесконечно много корней )
;===================================================================
solve_square:
	
	cmp eax, 0.0          ;проверяем, можно ли свеси уравнение к линейному bx + c = 0
	je prepare_sol_lin_1

	cmp ecx, 0.0          ;проверяем, можно ли свеси уравнение к линейному ax + b = 0
	je prepare_sol_lin_2 

	mul ecx, eax          ;честно вычисляем дискриминант
	mul ecx, 4.0
	mov edx, ebx
	mul edx, edx
	sub edx, ecx
	mov ecx, edx          ;теперь в ecx лежит дискриминант

	cmp ecx, 0.0          ;узнаем знак дискриминанта
	je D_is_zero
	ja D_is_pos
	jb D_is_neg

D_is_zero:                ;D == 0
	mov edx, 1.0
	mov esi, ebx
	mul esi, -0.5
	div esi, eax
	jmp end_solve_square

D_is_pos:                 ;D > 0
	mov edi, ebx
	mul edi, -1.0
	mov esi, edi

	push eax
	sqrt ecx
	mov ecx, eax
	pop eax

	add edi, ecx
	sub esi, ecx

	mul eax, 2.0

	div edi, eax
	div esi, eax

	mov edx, 2.0
	jmp end_solve_square

D_is_neg:                 ;D < 0
	mov edx, 0
	jmp end_solve_square


prepare_sol_lin_1:        ;производим решение уравнения bx + c = 0
	mov eax, ebx
	mov ebx, ecx
	call solve_linear	  ;количество корней будет записано в edx
	mov esi, edi
	jmp end_solve_square

prepare_sol_lin_2:        ;производим решение уравнения ax + b = 0
	mov esi, 0.0
	call solve_linear
	cmp edi, 0.0
	je one_root
	mov edx, 2.0          ;вообще количество корней будет равно 2, если только b!=0
	jmp end_solve_square
one_root:                 ;если все же получилось так, что корень только один
	jmp end_solve_square

end_solve_square:
	ret

	
main:
	; коэффициенты квадратного уравнения ax^2 + bx + c = 0 соответственно лежат в eax,ebx,ecx
	mov eax, 1.0
	mov ebx, -3.0
	mov ecx, 2.0
	call solve_square
	; корни корней лежат eax,ebx а их количество в ecx
	mov eax, esi
	mov ebx, edi
	mov ecx, edx
	; отключаем работу с дробями
	fpmoff
hlt